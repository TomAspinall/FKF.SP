<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Fast Kalman Filtering using Sequential Processing</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>
<style type="text/css">
a.anchor-section {margin-left: 10px; visibility: hidden; color: inherit;}
a.anchor-section::before {content: '#';}
.hasAnchor:hover a.anchor-section {visibility: visible;}
</style>
<script>// Anchor sections v1.0 written by Atsushi Yasumoto on Oct 3rd, 2020.
document.addEventListener('DOMContentLoaded', function() {
  // Do nothing if AnchorJS is used
  if (typeof window.anchors === 'object' && anchors.hasOwnProperty('hasAnchorJSLink')) {
    return;
  }

  const h = document.querySelectorAll('h1, h2, h3, h4, h5, h6');

  // Do nothing if sections are already anchored
  if (Array.from(h).some(x => x.classList.contains('hasAnchor'))) {
    return null;
  }

  // Use section id when pandoc runs with --section-divs
  const section_id = function(x) {
    return ((x.classList.contains('section') || (x.tagName === 'SECTION'))
            ? x.id : '');
  };

  // Add anchors
  h.forEach(function(x) {
    const id = x.id || section_id(x.parentElement);
    if (id === '') {
      return null;
    }
    let anchor = document.createElement('a');
    anchor.href = '#' + id;
    anchor.classList = ['anchor-section'];
    x.classList.add('hasAnchor');
    x.appendChild(anchor);
  });
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Fast Kalman Filtering using Sequential Processing</h1>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>This document provides worked examples of Kalman Filtering through the FKF.SP package and the fkf.SP function. The fkf function is a well-established function call of the well-known Kalman Filter algorithm that is designed to maximize computational efficiency of the filtering process. The fkf.SP function builds from this by taking the additional assumption that the error of observations are independent and therefore filtering can be performed through a univariate treatment of the multivatiate process - increasing computational efficiency in the general case. This vignette showcases three examples that were first presented within the FKF package and associated vignette. The following examples are structured to both showcase the functionality of the package whilst further showcasing the increase in computational speed between the fkf.SP and fkf functions. The examples presented are relatively simple Kalman Filtering problems, whilst the relative increase in Filtering computational speed would be greater for problems with more dimensions in observations and the state vector.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(FKF.SP)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">library</span>(FKF)</span></code></pre></div>
</div>
<div id="example-1---arma21-model-estimation." class="section level2">
<h2>Example 1 - ARMA(2,1) model estimation.</h2>
<p>Autoregression Moving Average models can be estimated through Kalman Filtering. See also help(makeARIMA) and help(KalmanRun).</p>
<p>Set constants:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">## Length of series</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>n &lt;-<span class="st"> </span><span class="dv">10000</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">## AR parameters</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>ar1 &lt;-<span class="st"> </span><span class="fl">0.6</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>ar2 &lt;-<span class="st"> </span><span class="fl">0.2</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>ma1 &lt;-<span class="st"> </span><span class="fl">-0.2</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>sigma &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="fl">0.2</span>)</span></code></pre></div>
<p>Sample from an ARMA(2, 1) process</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>a &lt;-<span class="st"> </span>stats<span class="op">::</span><span class="kw">arima.sim</span>(<span class="dt">model =</span> <span class="kw">list</span>(<span class="dt">ar =</span> <span class="kw">c</span>(ar1, ar2), <span class="dt">ma =</span> ma1), <span class="dt">n =</span> n,</span>
<span id="cb3-2"><a href="#cb3-2"></a>            <span class="dt">innov =</span> <span class="kw">rnorm</span>(n) <span class="op">*</span><span class="st"> </span>sigma)</span></code></pre></div>
<p>Create a state space representation out of the four ARMA parameters</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>arma21ss &lt;-<span class="st"> </span><span class="cf">function</span>(ar1, ar2, ma1, sigma) {</span>
<span id="cb4-2"><a href="#cb4-2"></a>Tt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(ar1, ar2, <span class="dv">1</span>, <span class="dv">0</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a>Zt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">0</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb4-4"><a href="#cb4-4"></a>ct &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>)</span>
<span id="cb4-5"><a href="#cb4-5"></a>dt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow =</span> <span class="dv">2</span>)</span>
<span id="cb4-6"><a href="#cb4-6"></a>GGt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>)</span>
<span id="cb4-7"><a href="#cb4-7"></a>H &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, ma1), <span class="dt">nrow =</span> <span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>sigma</span>
<span id="cb4-8"><a href="#cb4-8"></a>HHt &lt;-<span class="st"> </span>H <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(H)</span>
<span id="cb4-9"><a href="#cb4-9"></a>a0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="co">## Diffuse assumption</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>P0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="fl">1e6</span>, <span class="dt">nrow =</span> <span class="dv">2</span>, <span class="dt">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">ct =</span> ct, <span class="dt">dt =</span> dt, <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt, <span class="dt">GGt =</span> GGt,</span>
<span id="cb4-13"><a href="#cb4-13"></a>            <span class="dt">HHt =</span> HHt))</span>
<span id="cb4-14"><a href="#cb4-14"></a>            }</span></code></pre></div>
<p>Parameter estimation is performed through maximum likelihood estimation (MLE). This involves optimizing the log-likelihood returned by the Kalman Filter through the ‘optim’ function.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># The objective function passed to &#39;optim&#39;</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>objective &lt;-<span class="st"> </span><span class="cf">function</span>(theta, yt, <span class="dt">SP =</span> F) {</span>
<span id="cb5-3"><a href="#cb5-3"></a>param &lt;-<span class="st"> </span><span class="kw">arma21ss</span>(theta[<span class="st">&quot;ar1&quot;</span>], theta[<span class="st">&quot;ar2&quot;</span>], theta[<span class="st">&quot;ma1&quot;</span>], theta[<span class="st">&quot;sigma&quot;</span>])</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co"># Kalman Filtering through the fkf.SP function:</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="cf">if</span>(SP){</span>
<span id="cb5-6"><a href="#cb5-6"></a> ans &lt;-<span class="st"> </span><span class="op">-</span><span class="st"> </span><span class="kw">fkf.SP</span>(<span class="dt">a0 =</span> param<span class="op">$</span>a0, <span class="dt">P0 =</span> param<span class="op">$</span>P0, <span class="dt">dt =</span> param<span class="op">$</span>dt, <span class="dt">ct =</span> param<span class="op">$</span>ct, </span>
<span id="cb5-7"><a href="#cb5-7"></a>               <span class="dt">Tt =</span> param<span class="op">$</span>Tt, <span class="dt">Zt =</span> param<span class="op">$</span>Zt, <span class="dt">HHt =</span> param<span class="op">$</span>HHt, <span class="dt">GGt =</span> param<span class="op">$</span>GGt, </span>
<span id="cb5-8"><a href="#cb5-8"></a>               <span class="dt">yt =</span> yt)</span>
<span id="cb5-9"><a href="#cb5-9"></a> }</span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="co"># Kalman Filtering through the fkf function:</span></span>
<span id="cb5-11"><a href="#cb5-11"></a> <span class="cf">else</span>{</span>
<span id="cb5-12"><a href="#cb5-12"></a> ans &lt;-<span class="st"> </span><span class="op">-</span><span class="st"> </span><span class="kw">fkf</span>(<span class="dt">a0 =</span> param<span class="op">$</span>a0, <span class="dt">P0 =</span> param<span class="op">$</span>P0, <span class="dt">dt =</span> param<span class="op">$</span>dt, <span class="dt">ct =</span> param<span class="op">$</span>ct, <span class="dt">Tt =</span> param<span class="op">$</span>Tt,</span>
<span id="cb5-13"><a href="#cb5-13"></a>            <span class="dt">Zt =</span> param<span class="op">$</span>Zt, <span class="dt">HHt =</span> param<span class="op">$</span>HHt, <span class="dt">GGt =</span> param<span class="op">$</span>GGt, <span class="dt">yt =</span> yt)<span class="op">$</span>logLik</span>
<span id="cb5-14"><a href="#cb5-14"></a> }</span>
<span id="cb5-15"><a href="#cb5-15"></a> <span class="kw">return</span>(ans)</span>
<span id="cb5-16"><a href="#cb5-16"></a>}</span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="co">##Optim minimizes functions, so the negative is returned</span></span></code></pre></div>
<p>Perform MLE:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>theta &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">ar =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>), <span class="dt">ma1 =</span> <span class="dv">0</span>, <span class="dt">sigma =</span> <span class="dv">1</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">###FKF Package:</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>start &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb6-6"><a href="#cb6-6"></a>FKF_estimation &lt;-<span class="st"> </span><span class="kw">optim</span>(theta, objective, <span class="dt">yt =</span> <span class="kw">rbind</span>(a), <span class="dt">hessian =</span> <span class="ot">TRUE</span>, <span class="dt">SP =</span> F)</span>
<span id="cb6-7"><a href="#cb6-7"></a>FKF_runtime =<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="co">###fkf.SP Package:</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>start &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb6-12"><a href="#cb6-12"></a>FKF.SP_estimation &lt;-<span class="st"> </span><span class="kw">optim</span>(theta, objective, <span class="dt">yt =</span> <span class="kw">rbind</span>(a), <span class="dt">hessian =</span> <span class="ot">TRUE</span>, <span class="dt">SP =</span> T)</span>
<span id="cb6-13"><a href="#cb6-13"></a>FKF.SP_runtime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span></code></pre></div>
<p>The MLE process applying both functions has returned identical estimated parameters:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">print</span>(<span class="kw">rbind</span>(FKF.SP_estimation<span class="op">$</span>par, FKF_estimation<span class="op">$</span>par))</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co">#&gt;            ar1       ar2        ma1     sigma</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="co">#&gt; [1,] 0.5936258 0.2029388 -0.1857085 0.4458019</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="co">#&gt; [2,] 0.5936258 0.2029388 -0.1857085 0.4458019</span></span></code></pre></div>
<p>As well as an identical call count number for both functions:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">FKF.SP =</span> FKF.SP_estimation<span class="op">$</span>counts[<span class="dv">1</span>], <span class="dt">FKF =</span> FKF_estimation<span class="op">$</span>counts[<span class="dv">1</span>]))</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co">#&gt; FKF.SP.function    FKF.function </span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co">#&gt;             295             295</span></span></code></pre></div>
<p>Utilizing Sequential Processing however, we’ve decreased processing time:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">FKF.SP =</span> FKF.SP_runtime, <span class="dt">FKF =</span> FKF_runtime))</span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="co">#&gt; Time differences in secs</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co">#&gt;  FKF.SP     FKF </span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="co">#&gt; 1.62588 2.81717</span></span></code></pre></div>
<p>The vignette of FKF shows how to filter the series with estimated parameter values and develop some plots for analysis purposes. fkf.SP is only appropriate for efficient parameter estimation, rather than the filtering under estimated parameters.</p>
</div>
<div id="example-2---local-level-model-for-the-niles-annual-flow" class="section level2">
<h2>Example 2 - Local level model for the Nile’s annual flow:</h2>
<p>This example presents differences in the computational time of the fkf.SP and fkf functions to the Nile dataset. It also shows the difference in log-likelihood values returned by the two functions that occurs when NAs are within observations.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="co">## Transition equation:</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co">## alpha[t+1] = alpha[t] + eta[t], eta[t] ~ N(0, HHt)</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="co">## Measurement equation:</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co">## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)</span></span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="co">##Complete Nile Data - no NA&#39;s</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>y_complete &lt;-<span class="st"> </span>y_incomplete &lt;-<span class="st"> </span>Nile</span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="co">##Incomplete Nile Data - two NA&#39;s are present:</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>y_incomplete[<span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">10</span>)] &lt;-<span class="st"> </span><span class="ot">NA</span></span>
<span id="cb10-10"><a href="#cb10-10"></a></span>
<span id="cb10-11"><a href="#cb10-11"></a></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="co">## Set constant parameters:</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>dt &lt;-<span class="st"> </span>ct &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>)</span>
<span id="cb10-14"><a href="#cb10-14"></a>Zt &lt;-<span class="st"> </span>Tt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>)</span>
<span id="cb10-15"><a href="#cb10-15"></a>a0 &lt;-<span class="st"> </span>y_incomplete[<span class="dv">1</span>]   <span class="co"># Estimation of the first year flow</span></span>
<span id="cb10-16"><a href="#cb10-16"></a>P0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">100</span>)     <span class="co"># Variance of &#39;a0&#39;</span></span>
<span id="cb10-17"><a href="#cb10-17"></a></span>
<span id="cb10-18"><a href="#cb10-18"></a><span class="co">## Parameter estimation - maximum likelihood estimation:</span></span>
<span id="cb10-19"><a href="#cb10-19"></a>Nile_MLE &lt;-<span class="st"> </span><span class="cf">function</span>(yt, SP){</span>
<span id="cb10-20"><a href="#cb10-20"></a><span class="co">##Unknown parameters initial estimates:</span></span>
<span id="cb10-21"><a href="#cb10-21"></a>GGt &lt;-<span class="st"> </span>HHt &lt;-<span class="st"> </span><span class="kw">var</span>(yt, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span><span class="fl">.5</span></span>
<span id="cb10-22"><a href="#cb10-22"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb10-23"><a href="#cb10-23"></a><span class="co">#fkf.SP function:</span></span>
<span id="cb10-24"><a href="#cb10-24"></a><span class="cf">if</span>(SP){</span>
<span id="cb10-25"><a href="#cb10-25"></a>  <span class="kw">return</span>(<span class="kw">suppressWarnings</span>(<span class="kw">optim</span>(<span class="kw">c</span>(<span class="dt">HHt =</span> HHt, <span class="dt">GGt =</span> GGt),</span>
<span id="cb10-26"><a href="#cb10-26"></a>        <span class="dt">fn =</span> <span class="cf">function</span>(par, ...)</span>
<span id="cb10-27"><a href="#cb10-27"></a>             <span class="op">-</span><span class="kw">fkf.SP</span>(<span class="dt">HHt =</span> <span class="kw">matrix</span>(par[<span class="dv">1</span>]), <span class="dt">GGt =</span> <span class="kw">matrix</span>(par[<span class="dv">2</span>]), ...),</span>
<span id="cb10-28"><a href="#cb10-28"></a>             <span class="dt">yt =</span> <span class="kw">rbind</span>(yt), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,</span>
<span id="cb10-29"><a href="#cb10-29"></a>             <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt)))</span>
<span id="cb10-30"><a href="#cb10-30"></a>} <span class="cf">else</span> {</span>
<span id="cb10-31"><a href="#cb10-31"></a><span class="co">#fkf function:</span></span>
<span id="cb10-32"><a href="#cb10-32"></a>  <span class="kw">return</span>(<span class="kw">optim</span>(<span class="kw">c</span>(<span class="dt">HHt =</span> HHt, <span class="dt">GGt =</span> GGt),</span>
<span id="cb10-33"><a href="#cb10-33"></a>        <span class="dt">fn =</span> <span class="cf">function</span>(par, ...)</span>
<span id="cb10-34"><a href="#cb10-34"></a>             <span class="op">-</span><span class="kw">fkf</span>(<span class="dt">HHt =</span> <span class="kw">matrix</span>(par[<span class="dv">1</span>]), <span class="dt">GGt =</span> <span class="kw">matrix</span>(par[<span class="dv">2</span>]), ...)<span class="op">$</span>logLik,</span>
<span id="cb10-35"><a href="#cb10-35"></a>             <span class="dt">yt =</span> <span class="kw">rbind</span>(yt), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,</span>
<span id="cb10-36"><a href="#cb10-36"></a>             <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt))</span>
<span id="cb10-37"><a href="#cb10-37"></a>}}</span></code></pre></div>
<p>Performing parameter estimation using complete data, the fkf and fkf.SP functions return identical results:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>fkf.SP_MLE_complete =<span class="st"> </span><span class="kw">Nile_MLE</span>(y_complete, <span class="dt">SP =</span> T)</span>
<span id="cb11-2"><a href="#cb11-2"></a>fkf_MLE_complete =<span class="st"> </span><span class="kw">Nile_MLE</span>(y_complete, <span class="dt">SP =</span> F)</span></code></pre></div>
<p>fkf.SP:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">print</span>(fkf.SP_MLE_complete[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="co">#&gt; $par</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="co">#&gt;       HHt       GGt </span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="co">#&gt;  1300.777 15247.773 </span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="co">#&gt; </span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="co">#&gt; $value</span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="co">#&gt; [1] 637.626</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="co">#&gt; </span></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="co">#&gt; $counts</span></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="co">#&gt; function gradient </span></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="co">#&gt;       57       NA</span></span></code></pre></div>
<p>fkf:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">print</span>(fkf_MLE_complete[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="co">#&gt; $par</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="co">#&gt;       HHt       GGt </span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="co">#&gt;  1300.777 15247.773 </span></span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="co">#&gt; </span></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="co">#&gt; $value</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="co">#&gt; [1] 637.626</span></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="co">#&gt; </span></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="co">#&gt; $counts</span></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="co">#&gt; function gradient </span></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="co">#&gt;       57       NA</span></span></code></pre></div>
<p>Performing parameter estimation using incomplete data returns identical estimated parameters, but different log-likelihood values:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a>fkf.SP_MLE_incomplete =<span class="st"> </span><span class="kw">Nile_MLE</span>(y_incomplete, <span class="dt">SP =</span> T)</span>
<span id="cb14-2"><a href="#cb14-2"></a>fkf_MLE_incomplete =<span class="st"> </span><span class="kw">Nile_MLE</span>(y_incomplete, <span class="dt">SP =</span> F)</span></code></pre></div>
<p>fkf.SP:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">print</span>(fkf.SP_MLE_incomplete[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])</span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="co">#&gt; $par</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="co">#&gt;       HHt       GGt </span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="co">#&gt;  1385.066 15124.131 </span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="co">#&gt; </span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="co">#&gt; $value</span></span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="co">#&gt; [1] 625.1676</span></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="co">#&gt; </span></span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="co">#&gt; $counts</span></span>
<span id="cb15-10"><a href="#cb15-10"></a><span class="co">#&gt; function gradient </span></span>
<span id="cb15-11"><a href="#cb15-11"></a><span class="co">#&gt;       53       NA</span></span></code></pre></div>
<p>fkf:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">print</span>(fkf_MLE_incomplete[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])</span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="co">#&gt; $par</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="co">#&gt;       HHt       GGt </span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="co">#&gt;  1385.066 15124.131 </span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="co">#&gt; </span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="co">#&gt; $value</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="co">#&gt; [1] 627.0055</span></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="co">#&gt; </span></span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="co">#&gt; $counts</span></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="co">#&gt; function gradient </span></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="co">#&gt;       53       NA</span></span></code></pre></div>
<p>The difference in log-likelihood values is equal to 1.8378771. This difference is equal to:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a><span class="co">#Number of NA values:</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>NA_values =<span class="st"> </span><span class="kw">length</span>(<span class="kw">which</span>(<span class="kw">is.na</span>(y_incomplete)))</span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="kw">print</span>( <span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span>NA_values <span class="op">*</span><span class="st"> </span><span class="kw">log</span>(<span class="dv">2</span> <span class="op">*</span><span class="st"> </span>pi))</span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="co">#&gt; [1] 1.837877</span></span></code></pre></div>
<p>This is because the fkf function instantiates its log-likelihood score by calculating <span class="math inline">\(- n \times d \times log(2\pi)\)</span>, where <span class="math inline">\(n\)</span> is the number of columns of object yt and <span class="math inline">\(d\)</span> is the number of rows of object yt. Because there are NA’s, however, the first term of the log-likelihood score would instead be <span class="math inline">\(- n \times (d-2) \times log(2\pi)\)</span>, explaining this difference in log-likelihood scores. The fkf function instantiates the log-likelihood score of two observations that are not actually observed.</p>
<div id="speed-comparison---nile-data-10000-iterations" class="section level3">
<h3>Speed Comparison - Nile Data (10,000 iterations):</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a><span class="co">#This test uses estimated parameters of complete data. </span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="co">#Please run the complete chunk for a fair comparison:</span></span>
<span id="cb18-3"><a href="#cb18-3"></a></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb18-5"><a href="#cb18-5"></a>start =<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="fl">1e4</span>) <span class="kw">fkf</span>(a0, P0, dt, ct, Tt, Zt, <span class="dt">HHt =</span> <span class="kw">matrix</span>(fkf_MLE_complete<span class="op">$</span>par[<span class="dv">1</span>]),</span>
<span id="cb18-7"><a href="#cb18-7"></a>                    <span class="dt">GGt =</span> <span class="kw">matrix</span>(fkf_MLE_complete<span class="op">$</span>par[<span class="dv">2</span>]), <span class="dt">yt =</span> <span class="kw">rbind</span>(y_complete))</span>
<span id="cb18-8"><a href="#cb18-8"></a>FKF_runtime =<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span>
<span id="cb18-9"><a href="#cb18-9"></a></span>
<span id="cb18-10"><a href="#cb18-10"></a>start =<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb18-12"><a href="#cb18-12"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="fl">1e4</span>) <span class="kw">fkf.SP</span>(a0, P0, dt, ct, Tt, Zt, <span class="dt">HHt =</span> <span class="kw">matrix</span>(fkf.SP_MLE_complete<span class="op">$</span>par[<span class="dv">1</span>]),</span>
<span id="cb18-13"><a href="#cb18-13"></a>                       <span class="dt">GGt =</span> <span class="kw">matrix</span>(fkf.SP_MLE_complete<span class="op">$</span>par[<span class="dv">2</span>]), <span class="dt">yt =</span> <span class="kw">rbind</span>(y_complete))</span>
<span id="cb18-14"><a href="#cb18-14"></a>fkf.SP_runtime =<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span>
<span id="cb18-15"><a href="#cb18-15"></a></span>
<span id="cb18-16"><a href="#cb18-16"></a><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">FKF.SP =</span> fkf.SP_runtime, <span class="dt">FKF =</span> FKF_runtime))</span>
<span id="cb18-17"><a href="#cb18-17"></a><span class="co">#&gt; Time differences in secs</span></span>
<span id="cb18-18"><a href="#cb18-18"></a><span class="co">#&gt;   FKF.SP      FKF </span></span>
<span id="cb18-19"><a href="#cb18-19"></a><span class="co">#&gt; 1.323574 2.040657</span></span></code></pre></div>
<p>Utilizing Sequential Processing has decreased processing time.</p>
</div>
</div>
<div id="example-3---tree-ring-data" class="section level2">
<h2>Example 3 - Tree Ring Data:</h2>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="co">## Transition equation:</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="co">## alpha[t+1] = alpha[t] + eta[t], eta[t] ~ N(0, HHt)</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="co">## Measurement equation:</span></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="co">## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)</span></span>
<span id="cb19-6"><a href="#cb19-6"></a></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="co">## tree-ring widths in dimensionless units</span></span>
<span id="cb19-8"><a href="#cb19-8"></a>y &lt;-<span class="st"> </span>treering</span>
<span id="cb19-9"><a href="#cb19-9"></a></span>
<span id="cb19-10"><a href="#cb19-10"></a><span class="co">## Set constant parameters:</span></span>
<span id="cb19-11"><a href="#cb19-11"></a>dt &lt;-<span class="st"> </span>ct &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>)</span>
<span id="cb19-12"><a href="#cb19-12"></a>Zt &lt;-<span class="st"> </span>Tt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>)</span>
<span id="cb19-13"><a href="#cb19-13"></a>a0 &lt;-<span class="st"> </span>y[<span class="dv">1</span>]            <span class="co"># Estimation of the first width</span></span>
<span id="cb19-14"><a href="#cb19-14"></a>P0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">100</span>)     <span class="co"># Variance of &#39;a0&#39;</span></span>
<span id="cb19-15"><a href="#cb19-15"></a></span>
<span id="cb19-16"><a href="#cb19-16"></a><span class="co">##Time comparison - Estimate parameters 10 times:</span></span>
<span id="cb19-17"><a href="#cb19-17"></a>start =<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb19-18"><a href="#cb19-18"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb19-19"><a href="#cb19-19"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)  fit.fkf &lt;-<span class="st"> </span><span class="kw">optim</span>(<span class="kw">c</span>(<span class="dt">HHt =</span> <span class="kw">var</span>(y, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span><span class="fl">.5</span>,</span>
<span id="cb19-20"><a href="#cb19-20"></a>                     <span class="dt">GGt =</span> <span class="kw">var</span>(y, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span><span class="fl">.5</span>),</span>
<span id="cb19-21"><a href="#cb19-21"></a>                   <span class="dt">fn =</span> <span class="cf">function</span>(par, ...)</span>
<span id="cb19-22"><a href="#cb19-22"></a>                     <span class="op">-</span><span class="kw">fkf</span>(<span class="dt">HHt =</span> <span class="kw">array</span>(par[<span class="dv">1</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)), <span class="dt">GGt =</span> <span class="kw">array</span>(par[<span class="dv">2</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)), ...)<span class="op">$</span>logLik,</span>
<span id="cb19-23"><a href="#cb19-23"></a>                   <span class="dt">yt =</span> <span class="kw">rbind</span>(y), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,</span>
<span id="cb19-24"><a href="#cb19-24"></a>                   <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt)</span>
<span id="cb19-25"><a href="#cb19-25"></a></span>
<span id="cb19-26"><a href="#cb19-26"></a>run.time_FKF =<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span>
<span id="cb19-27"><a href="#cb19-27"></a></span>
<span id="cb19-28"><a href="#cb19-28"></a></span>
<span id="cb19-29"><a href="#cb19-29"></a>start =<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb19-30"><a href="#cb19-30"></a><span class="co">##When FKF.SP is input poorly specified parameters </span></span>
<span id="cb19-31"><a href="#cb19-31"></a><span class="co">##(ie. log-likelihood = NA) is output a warning:</span></span>
<span id="cb19-32"><a href="#cb19-32"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb19-33"><a href="#cb19-33"></a><span class="kw">suppressWarnings</span>(</span>
<span id="cb19-34"><a href="#cb19-34"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)  fit.fkf.SP &lt;-<span class="st"> </span><span class="kw">optim</span>(<span class="kw">c</span>(<span class="dt">HHt =</span> <span class="kw">var</span>(y, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span><span class="fl">.5</span>,</span>
<span id="cb19-35"><a href="#cb19-35"></a>                        <span class="dt">GGt =</span> <span class="kw">var</span>(y, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span><span class="fl">.5</span>),</span>
<span id="cb19-36"><a href="#cb19-36"></a>                      <span class="dt">fn =</span> <span class="cf">function</span>(par, ...)</span>
<span id="cb19-37"><a href="#cb19-37"></a>                        <span class="op">-</span><span class="kw">fkf.SP</span>(<span class="dt">HHt =</span> <span class="kw">array</span>(par[<span class="dv">1</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)), <span class="dt">GGt =</span> <span class="kw">matrix</span>(par[<span class="dv">2</span>]), ...),</span>
<span id="cb19-38"><a href="#cb19-38"></a>                      <span class="dt">yt =</span> <span class="kw">rbind</span>(y), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,</span>
<span id="cb19-39"><a href="#cb19-39"></a>                      <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt)</span>
<span id="cb19-40"><a href="#cb19-40"></a>)</span>
<span id="cb19-41"><a href="#cb19-41"></a>run.time_FKF.SP =<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span>
<span id="cb19-42"><a href="#cb19-42"></a></span>
<span id="cb19-43"><a href="#cb19-43"></a><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">fkf.SP =</span> run.time_FKF.SP, <span class="dt">fkf =</span> run.time_FKF))</span>
<span id="cb19-44"><a href="#cb19-44"></a><span class="co">#&gt; Time differences in secs</span></span>
<span id="cb19-45"><a href="#cb19-45"></a><span class="co">#&gt;   fkf.SP      fkf </span></span>
<span id="cb19-46"><a href="#cb19-46"></a><span class="co">#&gt; 2.710178 3.679278</span></span>
<span id="cb19-47"><a href="#cb19-47"></a></span>
<span id="cb19-48"><a href="#cb19-48"></a><span class="co">## Filter tree ring data with estimated parameters using fkf:</span></span>
<span id="cb19-49"><a href="#cb19-49"></a>fkf.obj &lt;-<span class="st"> </span><span class="kw">fkf</span>(a0, P0, dt, ct, Tt, Zt, <span class="dt">HHt =</span> <span class="kw">array</span>(fit.fkf<span class="op">$</span>par[<span class="dv">1</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)),</span>
<span id="cb19-50"><a href="#cb19-50"></a>               <span class="dt">GGt =</span> <span class="kw">array</span>(fit.fkf<span class="op">$</span>par[<span class="dv">2</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)), <span class="dt">yt =</span> <span class="kw">rbind</span>(y))</span></code></pre></div>
<p>Utilizing Sequential Processing has decreased processing time.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
